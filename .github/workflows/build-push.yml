name: Org Kratos Build & Push

on:
  workflow_call:
    inputs:
      registry:
        type: string
        required: true

      image_name:
        type: string
        required: false
        default: ""

      working_dir:
        type: string
        default: "./service"

      context:
        type: string
        default: "./service"

      go_version:
        type: string
        default: "1.25.0"

      go_build_target:
        type: string
        default: "./cmd/service"

      runtime_image:
        type: string
        default: "gcr.io/distroless/static:nonroot"

      expose_ports:
        type: string
        default: ""

      config_file:
        type: string
        default: "configs/config.yaml"

      entrypoint_args:
        type: string
        default: "-conf /configs"

      copy_env_into_image:
        type: string
        default: "false"

      no_cache:
        type: string
        default: "false"

    secrets:
      REGISTRY_LOGIN:
        required: true
      REGISTRY_PASS:
        required: true
      ENV_FILE:
        required: false

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Resolve meta (name + tag from latest git tag ONLY)
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          if [ -n "${{ inputs.image_name }}" ]; then
            NAME="${{ inputs.image_name }}"
          else
            NAME="${{ github.event.repository.name }}"
          fi

          GIT_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
          if [ -z "$GIT_TAG" ]; then
            echo "::error ::No git tags found. Version MUST come from the latest tag. Create a tag like v0.12 and push it."
            exit 1
          fi

          # v0.12 -> 0.12 (если хочешь сохранять 'v', убери #v)
          TAG="${GIT_TAG#v}"

          IMAGE="${{ inputs.registry }}/${NAME}:${TAG}"

          echo "name=$NAME" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"

      - name: Create .env (optional)
        if: ${{ inputs.copy_env_into_image == 'true' }}
        working-directory: ${{ inputs.working_dir }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.ENV_FILE }}" ]; then
            echo "::warning ::copy_env_into_image=true but ENV_FILE secret is empty"
            exit 0
          fi
          printf '%s\n' "${{ secrets.ENV_FILE }}" > .env

      - name: Generate Dockerfile
        id: gen
        shell: bash
        working-directory: ${{ inputs.working_dir }}
        run: |
          set -euo pipefail

          GEN_DF="${RUNNER_TEMP}/Dockerfile.gen"
          PORTS="$(echo "${{ inputs.expose_ports }}" | tr ',' ' ' | xargs || true)"

          echo "# syntax=docker/dockerfile:1.7" > "$GEN_DF"
          {
            echo
            echo "FROM golang:${{ inputs.go_version }} AS builder"
            echo "WORKDIR /src"
            echo "COPY go.mod go.sum ./"
            echo "RUN --mount=type=cache,target=/go/pkg/mod \\"
            echo "    --mount=type=cache,target=/root/.cache/go-build \\"
            echo "    go mod download"
            echo "COPY . ."
            echo "RUN --mount=type=cache,target=/go/pkg/mod \\"
            echo "    --mount=type=cache,target=/root/.cache/go-build \\"
            echo "    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \\"
            echo "    go build -trimpath -ldflags=\"-s -w -buildid=\" -o /out/service.linux ${{ inputs.go_build_target }}"
            echo
            echo "FROM ${{ inputs.runtime_image }}"
            echo "WORKDIR /app"
            echo "COPY --from=builder /out/service.linux /app/service.linux"
            echo "COPY ${{ inputs.config_file }} /configs/config.yaml"
            if [ "${{ inputs.copy_env_into_image }}" = "true" ]; then
              echo "COPY .env /app/.env"
            fi
            if [ -n "$PORTS" ]; then
              echo "EXPOSE $PORTS"
            fi
            echo "ENTRYPOINT [\"/app/service.linux\"]"
            echo "CMD ${{ inputs.entrypoint_args }}"
          } >> "$GEN_DF"

          echo "dockerfile=$GEN_DF" >> "$GITHUB_OUTPUT"

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_LOGIN }}
          password: ${{ secrets.REGISTRY_PASS }}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: ${{ format('{0}/{1}', github.workspace, inputs.context) }}
          file: ${{ steps.gen.outputs.dockerfile }}
          tags: ${{ steps.meta.outputs.image }}
          push: "true"
          no-cache: ${{ inputs.no_cache }}
          provenance: "false"
          sbom: "false"

      - name: Summary
        if: ${{ always() }}
        shell: bash
        run: |
          echo "## Build & Push Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "- Tag (from git): \`${{ steps.meta.outputs.tag }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Image: \`${{ steps.meta.outputs.image }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Working dir: \`${{ inputs.working_dir }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Context: \`${{ inputs.context }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- no_cache: \`${{ inputs.no_cache }}\`" >> "$GITHUB_STEP_SUMMARY"
